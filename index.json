[{"content":"Cześć. W dzisiejszym artykule chciałbym poruszyć temat architektury heksagonalnej znanej również jako architektura Portów i Adapterów (ang. Ports \u0026amp; Adapters). Mam nadzieję, że uda mi się przedstawić Tobie w prosty sposób jak zaimplementować architekturę heksagonalną w Twoim projekcie. Ale zacznijmy od początku.\nCzym jest hexagonal architecture? Architektura heksagonalna to wzorzec architektoniczny, który pozwala na implementację logiki biznesowej, całkowicie odseparowanej od zależności. Intencją architektury heksagonalnej jest możliwość wykorzystania napisanej aplikacji przez dowolne wejście (np. UI, aplikacja konsolowa lub API),a także testów automatycznych. Wykorzystując porty i adaptery mamy możliwość prostego uruchomienia testów w izolacji od zewnętrznych serwisów lub usług (np. bazy danych).\nAllow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases.\n\u0026ndash; Alistair Cockburn\nZ założenia koncept ten pozwala na modularyzację aplikacji, a co za tym idzie, na bezproblemową zmianę komponentów. Pozwala również na łatwą implementację nowego interfejsu użytkownikam, jak na przykład dodanie REST API lub po prostu łatwe testowanie domeny biznesowej z wykorzystaniem Stubów lub Mocków.\nInnymi słowy odseparowujemy implementację logiki biznesowej od zewnętrznych zależności.\nDzięki wykorzystaniu konceptu architektury heksagonalnej unikamy przenikania logiki biznesowej do interfejsu użytkownika, a kod jest łatwiejszy do przetestowania.\nNa czym polega cała „magia” portów i adapterów? To bardzo proste, wykorzystuje podstawowy element programowania obiektowego – interfejsy oraz regułę odwróconych zależności (ang. dependency inversion principle).\nDobrze, poznaliśmy już podstawy architektury, teraz możemy przejść do „mięsa” hexagonu!\nJak wygląda struktura? Architektura portów i adapterów bazuje na modelu warstwowym i dzieli się na dwie warstwy – Domeny i Infrastruktury. W przeciwieństwie do architektury warstwowej, w której w zależności od wizualizacji kierunek zależności biegnie z góry na dół lub inaczej z zewnątrz do środka, w architekturze heksagonalnej kierunek zależności biegnie od Domeny na zewnątrz. W architekturze heksagonalnej oprócz warstw wyróżniamy jeszcze porty i adaptery, za pomocą których komunikujemy się między warstwami.\nPorty i adaptery z kolei dzielimy wejściowe oraz wyjściowe na każdym z boków umownego heksagonu.\nPort rozumiany jest jako interfejs wejściowy do aplikacji. Przykładowo może być to request HTTP, który uruchamia żądanie do naszej aplikacji. Port również rozumiany jest jako dostęp do danych, np port bazy danych. Z drugiej strony mamy adaptery, czyli coś co dopasowuje się do portu\nTechnicznie port rozumiany jest jako interfejs, a adapter to jego implementacja. To trochę jak z USB, który jest umownym interfejsem i producenci dostosowują do niego swoje urządzenia. W programistycznym świecie mamy przykład portu Repozytorium. Zawiera ono metodę, która powinna zwrócić tablicę obiektów danej klasy. Jak może wyglądać tutaj adapter? Z punktu widzenia domeny nie ma to kompletnie żadnego znaczenia. W zależności od potrzeby możemy wykorzystać tutaj implementację za pomocą natywnych zapytań do bazy danych lub z wykorzystaniem abstrakcji, np. Doctrine. Jednak to nie musi być silnik bazy danych, a na przykład zewnętrzna usługa z interfejsem API. Idąc dalej, może to być jeden z naszych mikroserwisów lub po prostu plik tekstowy.\n1 2 3 4 5 6 7 \u0026lt;?php interface CustomerRepository { /** @return Customer[] */ public function findAll(): array; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php class CustomerMysqlRepository implements CustomerRepository { /** @return SomeClass[] */ public function findAll(): array { $stmt = $this-\u0026gt;connection-\u0026gt;prepare(\u0026#39;SELECT uuid, name FROM user\u0026#39;); $stmt-\u0026gt;exec(); $result = [] foreach($row = $stmt-\u0026gt;fetch()) { $result[] = new Customer($row[\u0026#39;uuid\u0026#39;], $row[\u0026#39;name\u0026#39;]); } return $result } } 1 2 3 4 5 6 7 8 9 \u0026lt;?php class CustomerDoctrineRepository implements CustomerRepository { /** @return Customer[] */ public function findAll(): array { return $this-\u0026gt;findBy([]); } } Potrzebujesz wysłać powiadomienie? Nie ma problemu, jedyne co musisz utworzyć to interfejs w warstwie domeny oraz jego implementacje w zewnętrznej warstwie.\nNa koniec bardzo ważna rzecz, warstwa domeny nie powinna zależeć od żadnych zewnętrznych zależności.\n","permalink":"https://g-stawarczyk.github.io/2021/01/architektura-heksagonalna/","summary":"Cześć. W dzisiejszym artykule chciałbym poruszyć temat architektury heksagonalnej znanej również jako architektura Portów i Adapterów (ang. Ports \u0026amp; Adapters). Mam nadzieję, że uda mi się przedstawić Tobie w prosty sposób jak zaimplementować architekturę heksagonalną w Twoim projekcie. Ale zacznijmy od początku.\nCzym jest hexagonal architecture? Architektura heksagonalna to wzorzec architektoniczny, który pozwala na implementację logiki biznesowej, całkowicie odseparowanej od zależności. Intencją architektury heksagonalnej jest możliwość wykorzystania napisanej aplikacji przez dowolne wejście (np.","title":"Architektura Heksagonalna"},{"content":"Cześć. W tym artykule skupimy się na zapisywaniu Value Object’ów w bazie danych. Jeżeli nie wiesz czym jest Obiekt Wartości, to zapraszam Cię do mojego poprzedniego artykułu: Value Object – Podstawowy element Domain Driven Design. Tymczasem przejdźmy do meritum.\nNa początek należy uzupełnić poprzedni artykuł, iż Value Object należy do Encji i nigdy nie jest zapisywany w bazie danych samemu sobie. Zazwyczaj zapisujemy je poprzez Agregat, o którym napiszę w kolejnym artykule. Istnieje kilka sposobów na zapis obiektu wartości w bazie danych.\nW świecie PHP istnieje wiele narzędzi ORM, które pomagają nam w codziennej pracy z bazami danych. Nie mniej jednak, w tym artykule skupię się jedynie na Doctrine, ponieważ znam go najlepiej oraz własnej implementacji ORM na podstawie Doctrine DBAL.\nObiekt wartości we własnym ORM Jeżeli implementujemy własne narzędzie ORM, musimy sami zadbać o wszystkie szczegóły, które pozwolą nam współpracować z bazami danych. Na przykładzie relacyjnej bazy danych MySQL, musimy utworzyć schemat tabeli Encji, którą będziemy zapisywać. Nasza przykładowa Encja to Person zawierająca Imię i Nazwisko jako Value Object, datę urodzenia oraz PESEL jako identyfikator.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php declare(strict_types=1); final class Person { private string $id; private Name $name; private DateTimeImmutable $birthDate; public function __construct(string $id, Name $name, DateTimeImmutable $birthDate) { $this-\u0026gt;id = $id; $this-\u0026gt;name = $name; $this-\u0026gt;birthDate = $birthDate; } } final class Name { private string $first; private string $last; public function __construct(string $first, string $last) { $this-\u0026gt;first = $first; $this-\u0026gt;last = $last; } public function first(): string { return $this-\u0026gt;firstName; } public function last(): string { return $this-\u0026gt;lastName; } } Dobrą praktyką jest utrzymywanie identyfikatora również jako Value Object, ale dla uproszczenia pominiemy ten aspekt. Obsługę Value Object’u jako identyfikator Encji omówimy w innym artykule.\nNa początek musimy utworzyć odpowiedni schemat:\n1 2 3 4 5 6 7 8 9 10 create table person ( id char(11) not null, name_first varchar(255) not null, name_last varchar(255) not null, date_birth date not null ); create unique index person_id_uindex on person (id); Analizując powyższą kwerendę SQL, możesz zauważyć, że Encja posiada 3 pola, a tabela w bazie danych 4. Wynika to z faktu, że nasz Value Object posiada w sobie 2 pola, które zostały oznaczone odpowiednio prefiksem name_ w tabeli bazy danych. Aby zapisać utworzoną encję w bazie, utwórzmy przykładowe repozytorium, które wykona zapytanie INSERT do bazy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php declare(strict_types=1); final class PersonDbalRepository extends DbalRepository implements PersonRepository { public function save(Person $person): void { $sql = \u0026#39;INSERT INTO person (id, name_first, name_last, birth_date) VALUES (?, ?, ?, ?);\u0026#39;; $stmt = $this-\u0026gt;connection()-\u0026gt;prepare($sql); $stmt-\u0026gt;bindValue(1, $person-\u0026gt;getId()); $stmt-\u0026gt;bindValue(2, $person-\u0026gt;getName()-\u0026gt;first()); $stmt-\u0026gt;bindValue(3, $person-\u0026gt;getName()-\u0026gt;last()); $stmt-\u0026gt;bindValue(4, $person-\u0026gt;getBirthDate()-\u0026gt;format(\u0026#39;Y-m-d\u0026#39;)); $stmt-\u0026gt;execute(); } } To wszystko, nasza encja została zapisana w bazie danych. Teraz tylko pozostało nam odczytać wiersz z bazy danych i zmaapować go na obiekt Encji oraz Value Objectu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php declare(strict_types=1); final class PersonDbalRepository extends DbalRepository implements PersonRepository { // ... public function find(string $id): Person { $sql = \u0026#39;SELECT * FROM person WHERE id = ?\u0026#39;; $stmt = $this-\u0026gt;connection()-\u0026gt;prepare($sql); $stmt-\u0026gt;bindValue(1, $id); $result = $stmt-\u0026gt;execute(); // ... return new Person( $row[\u0026#39;id\u0026#39;], new Name($row[\u0026#39;name_first\u0026#39;], $row[\u0026#39;name_last\u0026#39;]), DateTimeImmutable::createFromFormat(\u0026#39;Y-m-d\u0026#39;, $row[\u0026#39;birth_date\u0026#39;]) ); } } Proste, prawda? Niestety niesie to za sobą kilka konsekwencji. Przy każdym odczycie danych z bazy, wywołany będzie konstruktor obiektów, który bardzo często będzie zawierał logikę walidacji. Spowoduje to wydłużenie czasu tworzenia obiektów. To jednak nie jest jeszcze takie złe. Wyobraźmy sobie, że w konstruktorze Encji którą tworzymy, wysyłamy zdarzenie domenowe: Osoba została utworzona (Tak wiem, dziwnie to brzmi :D). Za każdym raziem, gdy będziemy odczytywać obiekt z bazy danych, zdarzenie zostanie wysłane i nie jest to poprawne zachowanie. Dlatego warto korzystać z gotowych i sprawdzonych narzędzi takich jak Doctrine, który tworzy nowy obiekt bezwykorzystania konstruktora.\nValue Object w Doctrine Zapisywanie Obiektu wartości za pomocą Doctrine można wykonać na 3 sposoby. Pierwszym z nich i chyba najłatwiejszym jest ręczne tworzenie Obiektu Wartości w metodzie get lub odpowiednie przypisanie do pól encji podczas wykonania metody set czy w konstruktorze.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;?php declare(strict_types=1); final class Name { private string $first; private string $last; public function __construct(string $first, string $last) { $this-\u0026gt;first = $first; $this-\u0026gt;last = $last; } public function first(): string { return $this-\u0026gt;first; } public function last(): string { return $this-\u0026gt;last; } } /** @Entity */ final class Person { /** * @Id * @Column(name=\u0026#34;id\u0026#34;, type=\u0026#34;string\u0026#34;, length=11) * @GeneratedValue(strategy=\u0026#34;NONE\u0026#34;) */ private string $id; /** @ORM\\Column(type=\u0026#34;string\u0026#34;) */ private string $nameFirst; /** @ORM\\Column(type=\u0026#34;string\u0026#34;) */ private string $nameLast; /** @ORM\\Column(type=\u0026#34;string\u0026#34;) */ private DateTimeImmutable $birthDate; public function __construct(string $id, Name $name, DateTimeImmutable $birthDate) { $this-\u0026gt;id = $id; $this-\u0026gt;name_first = $name-\u0026gt;first(); $this-\u0026gt;name_last = $name-\u0026gt;last(); $this-\u0026gt;birthDate = $birthDate; } public function getName(): Name { return new Name($this-\u0026gt;name_first, $this-\u0026gt;name_last); } } Proste i szybkie rozwiązanie, jednak mamy odrobinę więcej kodu do utrzymania.\nEmbeddables Drugim sposobem jest wykorzystanie mechanizmu Embedded. Na początek wyrzućmy pola $name_first oraz $name_last na rzecz jednego pola $name oraz dodajmy mapping encji. Dla uproszczenia jako adnotacje:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;?php declare(strict_types=1); /** @Embeddable */ final class Name { /** @ORM\\Column(type=\u0026#34;string\u0026#34;) */ private string $first; /** @ORM\\Column(type=\u0026#34;string\u0026#34;) */ private string $last; public function __construct(string $first, string $last) { $this-\u0026gt;first = $first; $this-\u0026gt;last = $last; } public function first(): string { return $this-\u0026gt;first; } public function last(): string { return $this-\u0026gt;last; } } /** @Entity */ final class Person { /** * @Id * @Column(name=\u0026#34;id\u0026#34;, type=\u0026#34;string\u0026#34;, length=11) * @GeneratedValue(strategy=\u0026#34;NONE\u0026#34;) */ private string $id; /** @Embedded(class=\u0026#34;Name\u0026#34;) */ private Name $name; /** @ORM\\Column(type=\u0026#34;string\u0026#34;) */ private DateTimeImmutable $birthDate; public function __construct(string $id, Name $name, DateTimeImmutable $birthDate) { $this-\u0026gt;id = $id; $this-\u0026gt;name = $name; $this-\u0026gt;birthDate = $birthDate; } public function getName(): Name { return $this-\u0026gt;name; } } Spójrz proszę na linię 3 oraz 37. W linii 3 oznaczyliśmy naszą klasę jako Embeddable, dzięki czemu Doctrine wie, że jest to Value Object, który będzie wykorzystywany w Encji. Tak właśnie zrobiliśmy, w linii 37 oznaczyliśmy pole $name adnotację Embedded, która mówi, że to pole jest Value Object’em o podanej klasie. Doctrine z tak skonfigurowaną Encją podczas odczytywania, przy wykorzystaniu swojej implementacji EntityRepository, utworzy nam poprawny obiekt Person z polem $name jako Value Object.\nProste, prawda? Niestety to rozwiązanie ma swoje minusy. W wersji Doctrine/ORM 2.x pole Embedded nie może być null’em. Prawdopodobnie Embbeded będzie mogło być nullem w wersja 3.x, która na dzień pisania postu jest jeszcze w fazie developmentu.\nJak poradzić sobie z tym problemem? Albo wybieramy sposób pierwszy opisany wyżej, albo wybieramy sposób trzeci. Spoiler ALERT! Jednak już na początku muszę Cię uprzedzić, że i to rozwiązanie ma swój minus. Niestety w naszym opisywanym przypadku, niestety nie pozwala on na implementację obiektu Name jako Value Object w naszej Encji.\nTen sposób to Własny Typ (ang. Custom Mapping Type). Sama implementacja jest również dość prosta i co ważne, pozwala na użycie opcji nullable.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?php declare(strict_types=1); use Doctrine\\DBAL\\Types\\Type; use Doctrine\\DBAL\\Platforms\\AbstractPlatform; class MyType extends Type { const MYTYPE = \u0026#39;mytype\u0026#39;; // modify to match your type name public function getSQLDeclaration(array $fieldDeclaration, AbstractPlatform $platform) { // return the SQL used to create your column type. To create a portable column type, use the $platform. } public function convertToPHPValue($value, AbstractPlatform $platform) { // This is executed when the value is read from the database. Make your conversions here, optionally using the $platform. } public function convertToDatabaseValue($value, AbstractPlatform $platform) { // This is executed when the value is written to the database. Make your conversions here, optionally using the $platform. } public function getName() { return self::MYTYPE; // modify to match your constant name } } Tak wygląda szablon implementacji własnego typu w dokumentacji Doctrine.\nJak poprawnie zaimplementować custom mapping type? Tym zajmiemy się w kolejnym artykule, w którym opiszemy jak użyć Value Object jako identyfikator. Z tego miejsca zapraszam Cię do śledzenia mojego bloga.\n","permalink":"https://g-stawarczyk.github.io/2020/12/persystencja-value-object-w-php/","summary":"Cześć. W tym artykule skupimy się na zapisywaniu Value Object’ów w bazie danych. Jeżeli nie wiesz czym jest Obiekt Wartości, to zapraszam Cię do mojego poprzedniego artykułu: Value Object – Podstawowy element Domain Driven Design. Tymczasem przejdźmy do meritum.\nNa początek należy uzupełnić poprzedni artykuł, iż Value Object należy do Encji i nigdy nie jest zapisywany w bazie danych samemu sobie. Zazwyczaj zapisujemy je poprzez Agregat, o którym napiszę w kolejnym artykule.","title":"Persystencja Value Object w PHP"},{"content":"Podczas programowania obiektowego bardzo często wykorzystujemy typy primitywne do przedstawienia jakiejś wartości. Przy tym bardzo często musimy zmierzyć się z przekazywaniem oraz modyfikacją tych wartości. Idąc dalej, chcemy mieć przecież poprawne dane, więc sprawdzamy ich poprawność dodając dodatkową logikę walidującą. A co w sytuacji, gdy daną wartość, która reprezentuje jakiś koncept, chcemy wykorzystać w więcej niż jednym miejscu? Duplikujemy logikę sprawdzania ich poprawności? Wybieramy specjalne miejsce aby utworzyć klasę walidacji, a może duplikujemy kod? Ciężki temat, szczególnie w późniejszym utrzymaniu, ale tutaj z pomocą przychodzi nam Value Object (obiekt wartości, wartość).\nCzym jest Value Object Value Object jest to prosty obiekt, który reprezentuje zmierzoną, wyliczoną lub opisaną wartość. Są to zazwyczaj bardzo małe obiekty takie jak zakres dat, pieniądz czy inne proste wartości jak identyfikator Encji. Jednak co ważne, w odróżnieniu od Encji, nie posiadają tożsamości.\nCzym jest tożsamość obiektu? W bardzo dużym skrócie jest to identyfikator, który nadajemy.\nMożemy sobie zadać pytanie, czy obiekt wartości w jednym projekcie może być bez problemu zawsze obiektem wartości w innym projekcie? Nie. Bardzo dobrym przykładem jest właśnie reprezentacja Pieniądza. Z jednej strony, dla większości dwa banknoty 10 zł są równe jeżeli ich nominały się zgadzają. Jednak dla Banku Centralnego bardzo ważną informacją jest numer seryjny banknotu. W takim przypadku nie będzie to już Obiekt Wartości a Encja.\nW powyższym przykładzie można zauważyć różnicę w porównywaniu Wartości oraz Encji. Obiekty wartości są równe, jeżeli ich zmierzone, wyliczone lub opisane wartości są równe. Encje zaś porównujemy za pomocą identyfikatorów.\nCharakterystyka Obiektów Wartości Mierzą, liczą lub opisują Jedna z podstawowych cech Value Object jest opisywanie, wyliczanie czy mierzenie wartości. Właśnie wartość to słowo klucz. Value Object nie jest rzeczą w domenie, a właśnie wartością. W podanym wcześniej przykładzie pieniądza, utworzony Value Object nie przedstawia pieniądza jako rzecz, a mierzy ilość określonej waluty. Szukając innych przykładów wartości możemy znaleźć Imię, Nazwisko lub Adres. Jednak zawsze musimy pamiętać, że wszystko zależy od kontekstu. W jednym systemie Adres może być Value Objectem, a w innym będzie musiał być Encją.\nNiezmienność i Side-Effect-Free Niezmienność (ang. Immutability), to kolejna ważna cecha wartości. Nie możemy dopuścić aby Value Object w swoim cyklu życia zmienił swój stan. Również musimy mieć na uwadze fakt, że obiekt ten musi być zawsze w poprawnym stanie.\nJak utworzyć taki obiekt, aby był niezmienny? Jednym z najprostszych sposobów jest możliwość tworzenia obiektów tylko przez konstruktor, a sam obiekt jest pozbawiony metod zmieniających stan.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php declare(strict_types=1); final class ValueObject { private string $value; public function __construct(string $value) { $this-\u0026gt;value = $value; } public function value(): string { return $this-\u0026gt;value; } } W prawdzie można tutaj zarzucić, że nie mamy tutaj w 100% zabezpieczenia przed zmianą stanu, bo przecież w PHP konstruktor może być odpalony kilka razy, a co za tym idzie? Wartość się zmieni\n1 2 3 4 5 6 $value = new ValueObject(\u0026#39;foo\u0026#39;); var_dump($value-\u0026gt;value()); // foo $value-\u0026gt;__construct(\u0026#39;bar\u0026#39;); var_dump($value-\u0026gt;value()); // bar Umówmy się jednak, kto taki coś robi? Gdyby jednak ktoś chciał się przed tym zabezpieczyć, to jednym z dobrych rozwiązań jest wykorzystanie metody fabrycznej. Rozwiązanie jest bardzo proste i wystarczy zmienić publiczny konstruktor na prywatny i dodać statyczną metodę, która zwróci nową instancję obiektu.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php declare(strict_types=1); final class ValueObject { private string $value; private function __construct(string $value) { $this-\u0026gt;value = $value; } public static function fromString(string $value): self { return new self($value); } public function value(): string { return $this-\u0026gt;value; } } Teraz próbując utworzyć nowy obiekt za pomocą new otrzymamy ostrzeżenie:\n1 2 3 $value = new ValueObject(\u0026#39;foo\u0026#39;); Warning: Uncaught Error: Call to private ValueObject::__construct() from invalid context in Jak wszyscy wiemy jedyną rzeczą stała w naszych systemach jest właśnie zmiana. Jeżeli mamy utrzymać nasz obiekt niezmiennym, jak w takim razie poradzić sobie z operacjami zmieniającymi stan. Tutaj również rozwiązanie jest bardzo proste -\u0026gt; należy utworzyć nową instancję obiektu. Value Object nie może posiadać metod typu set. To wszystko oznacza, że nie zmieniasz wartości istniejącego już obiektu, tylko otrzymujesz nowy obiekt wartości.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php declare(strict_types=1); final class ValueObject { private int $value; public function __construct(int $value) { $this-\u0026gt;value = $value; } public function add(int $value): self { return new self($this-\u0026gt;value + $value); } public function value(): int { return $this-\u0026gt;value; } } Porównywalność wartości Value Objecty możemy jak każdy inny obiekt porównywać ze sobą. Musimy natomiast pamiętać, że równość wartości występuje wtedy, gdy wartości obu obiektów są takie same. Nie ma tutaj znaczenia, że jest to inna instancja klasy, ważne jest jaką wartość ze sobą niesie.\nIstnieje kilka sposobów porównywania wartości. Najprostszą, a zarazem najmniej polecaną jest użycie operatora przyrównania ==. Dwa obiekty będą równe jeżeli ich klasy oraz wartości są identyczne.\n1 2 3 4 5 6 7 8 9 10 11 $value1 = new ValueObject(10); $value2 = new ValueObject(10); var_dump($value1 == $value2); // true $value1 = new ValueObject(10); $value2 = new ValueObject(9); var_dump($value1 == $value2); // false Osobiście jednak nie jestem fanem porównania za pomocą == i gdy tylko widzę takie porównanie w legacy code, staram się je zmienić na operator identyczności ===. Operator ten jednak nie nadal się do porównywania obiektów, ponieważ aby obiekty były równe, muszą odnosić się do tego samego obiektu w pamięci.\n1 2 3 4 5 6 7 8 9 10 11 $value1 = new ValueObject(10); $value2 = new ValueObject(10); var_dump($value1 === $value2); // false $value1 = new ValueObject(10); $value2 = $value1; var_dump($value1 === $value2); // true Drugą i chyba najbardziej polecaną opcją na porównywanie wartości jest utworzenie dedykowanej metody, która porówna nam obiekty. Metodę taką implementujemy w Value Object i jako argument podajemy obiekt tej samej klasy. Sama metoda w sobie jest bardzo prosta, gdyż za pomocą operatora identyczności porównuje wartość aktualnego obiektu z wartością drugiego obiektu. Ważna uwaga, jeżeli nasz obiekt posiada więcej niż 1 wartość, należy porównać wszystkie wartości.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php declare(strict_types=1); final class ValueObject { private int $value; public function __construct(int $value) { $this-\u0026gt;value = $value; } public function equals(ValueObject $value): bool { return $this-\u0026gt;value === $value-\u0026gt;value(); } public function value(): int { return $this-\u0026gt;value; } } Istnieje jeszcze trzecia metoda, o której dobry programista nigdy nie powinien pomyśleć. Tam gdzie chcesz porównać Value Object’y, po prostu porównaj ich wartości if’em w każdym miejscu gdzie tego potrzebujesz. Chyba nie muszę mówić jak to wygląda i czym się ostatecznie zakończy? 🙂\nKoncept Whole Value Pattern Tak jak wspomniałem we wcześniejszym akapicie, obiekty wartości muszą być zawsze w poprawnym stanie. Stąd wartości powinny spełniać koncept Whole Value Pattern zdefiniowany przez Ward’a Cunningham’a w The checks Pattern Language of Information Integrity w 1994 roku. Aby zapewnić poprawny stan obiektu, podczas jego tworzenia należy sprawdzać wprowadzane wartości. Sprawdzanie to powinno odbywać się wewnątrz Value Object’u. Dlaczego robimy to wewnątrz obiektu? Wyobrażmy sobie sytuację, że nasz obiekt zawiera się w jakimś innym obiekcie, na przykład Encji. Zgodzisz się ze mną, że walidowanie czy Value Object posiada poprawny stan nie jest odpowiedzialnością Encji lub innej klasy. Narusza to przecież zasadę jednej odpowiedzialności (ang. Single Responibility Principle).\nTo Value Object or not to Value Object Mam nadzieję, że po przeczytaniu artykułu również tak jak ja, uważasz, że obiekty wartości są bardzo przydatne w modelowaniu Domeny. Rozwiązują one wiele problemów, przy czym są bardzo łatwe w implementacji oraz utrzymaniu. Dodatkowo w ściśle określonym kontekście każdy ekspert domenowy oraz programista dokładnie wie co oznacza przedstawiana wartość i jakie mamy wobec nich oczekiwania.\nDaj znać w komentarzach co sądzisz o Value Object’ach. Jeżeli masz jakieś ciekawe doświadczenia z obiektami wartości, z chęcią wymienię się doświadczeniem w komentarzach.\n","permalink":"https://g-stawarczyk.github.io/2020/09/value-object-podstawowy-element-domain-driven-design/","summary":"Podczas programowania obiektowego bardzo często wykorzystujemy typy primitywne do przedstawienia jakiejś wartości. Przy tym bardzo często musimy zmierzyć się z przekazywaniem oraz modyfikacją tych wartości. Idąc dalej, chcemy mieć przecież poprawne dane, więc sprawdzamy ich poprawność dodając dodatkową logikę walidującą. A co w sytuacji, gdy daną wartość, która reprezentuje jakiś koncept, chcemy wykorzystać w więcej niż jednym miejscu? Duplikujemy logikę sprawdzania ich poprawności? Wybieramy specjalne miejsce aby utworzyć klasę walidacji, a może duplikujemy kod?","title":"Value Object – Podstawowy element Domain Driven Design"},{"content":"Cześć. Jeżeli tutaj trafiłeś, to znaczy, że szukasz informacji na temat DDD – Domain Driven Design. Chciałbym Cię zaprosić do serii artykułów poświęconych metodologii DDD. Postaram się Tobie w zrozumiały sposób przybliżyć czym jest DDD oraz kiedy warto stosować to podejście.\nW trakcie całej serii pojawią się przykłady w języku PHP, które dopełnią całość, a Tobie czytelniku, dostarczą praktycznej wiedzy w zakresie wykorzystania Domain Driven Design.\nDDD – co to takiego? Domain Driven Design jest to koncept służący do projektowania systemów, który polega na tym, aby oprogramowanie jak najbardziej odzwierciedlało rzeczywisty system lub proces. Kod, który napiszemy, powinien być odzwierciedleniem biznesu, a wszechobecny język (ang. ubiquitous language) użyty w projekcie powinien być spójny i zrozumiały z „biznesem”.\nInnymi słowy, DDD to zestaw narzędzi, struktur oraz terminologii, których używamy podczas projektowania i implementacji modeli biznesowych. Jedną z najważniejszych założeń konceptu DDD jest głębokie nastawienie na współpracę między osobami z „biznesu”, a zespołem technicznym odpowiedzialnym za aplikację.\nKim są „osoby z biznesu”? Są to osoby, często nietechniczne, które mają bardzo dużą wiedzę na temat dziedziny biznesu klienta i procesów jakie tam zachodzą, a jakie aplikacja ma rozwiązać. Takie osoby zwane są ekspertami domenowymi. Nie martwcie się, nie są to osoby, które tworzą oprogramowanie. Eksperci domenowi pomagają zrozumieć architektom i programistom dziedzinę, wspierając ich wiedzą biznesową.\nDomena W najprostszych słowach, domena to obszar biznesu, z którym pracujesz i problemy jakie musi rozwiązać. Model, który zostanie zaprojektowany jest rozwiązaniem problemu biznesowego. Domena nie skupia się na technicznych aspektach takich jak na przykład framework, czy baza danych. Jeżeli Twoim zadaniem jest zaprojektowanie aplikacji z ogłoszeniami, Domeną Twojej aplikacji będzie wszystko co jest związane bezpośrednio z ogłoszeniami i ma być zaimplementowane w aplikacji (np. reguły biznesowe, czy problemy).\nJedną z najważniejszych rzeczy w DDD jest wyznaczenie języka wszechobecnego (ang. Ubiquitous language), którym będzie podążał model Domenowy.\nWszechobecny język Ubiquitous language to definicja zrozumiałego języka dla ekspertów domenowych oraz programistów implementujących zaprojektowany system. Zdefiniowany język musi mieć swoje odzwierciedlenie w Domenie aplikacji. Wyznaczenie wspólnego, uniwersalnego języka jest kluczem do rozwiązania niejasności, niezrozumienia i barier w komunikacji pomiędzy zespołem programistycznym a biznesem.\nWszechobecny język rozwija się wraz z rosnącym biznesem.\nDomain experts should object to terms or structures that are awkward or inadequate to convey domain understanding; developers should watch for ambiguity or inconsistency that will trip up design.\n\u0026ndash; Eric Evan\nMam nadzieję, że wyjaśniłem Ci w zrozumiały sposób czym jest Domain Driven Design. W kolejnych artykułach zagłębimy się w koncept DDD, w którym poznamy nieco przykładów ze świata DDD.\n","permalink":"https://g-stawarczyk.github.io/2020/07/ddd-domain-driven-design/","summary":"Cześć. Jeżeli tutaj trafiłeś, to znaczy, że szukasz informacji na temat DDD – Domain Driven Design. Chciałbym Cię zaprosić do serii artykułów poświęconych metodologii DDD. Postaram się Tobie w zrozumiały sposób przybliżyć czym jest DDD oraz kiedy warto stosować to podejście.\nW trakcie całej serii pojawią się przykłady w języku PHP, które dopełnią całość, a Tobie czytelniku, dostarczą praktycznej wiedzy w zakresie wykorzystania Domain Driven Design.\nDDD – co to takiego?","title":"DDD – Domain Driven Design"},{"content":"Cześć. W dzisiejszym wpisie sprawdzimy jak działa najnowsza wersja menadżera zależności composer w wersji 2.0.0-alpha1. Porównamy jak wygląda działanie, czas wykonywania zadania oraz zużycie pamięci RAM podczas operacji instalowania, aktualizowania oraz dodawania nowej biblioteki.\nProjekt, na którym będziemy testować menadżera zbudowany jest z wykorzystaniem Symfony 4.2 i wymaga 36 bibliotek – tyle pozycji wpisanych jest w pliku composer.json. Po uwzględnieniu zależności wszystkich bibliotek mamy 128 paczek.\nSzybsze pobieranie Najbardziej wyczekiwaną i zarazem najbardziej zauważalną zmianą w drugiej wersji composera jest zmieniony workflow instalowania, dodawania, aktualizacji czy usuwania paczek, co ma znaczący wpływ na wydajność. W wersji 1.x menadżer pobiera i instaluje paczka po paczce, a w wersji 2.x menadżer najpierw pobiera paczki oraz ich meta dane a następnie po zakończeniu ściągania instaluje je. Wszystko to dzieje się równolegle. Dzięki takiemu zabiegowi całość działa o wiele szybciej. Zobaczmy poniższe logi, jak wyglądała proces instalowania:\ncomposer 1.10.7\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 www-data@grzegorz-php74:~/project$ composer install --no-cache --no-scripts --profile [9.2MiB/0.02s] Loading composer repositories with package information [9.6MiB/0.02s] Installing dependencies (including require-dev) from lock file [10.5MiB/0.05s] Package operations: 128 installs, 0 updates, 0 removals [10.5MiB/0.05s] - Installing ocramius/package-versions (1.8.0): [10.6MiB/0.05s] [10.6MiB/0.72s] Downloading (0%) [10.6MiB/0.72s] Downloading (5%) [10.6MiB/0.72s] Downloading (10%) ... [11.9MiB/59.44s] - Installing symfony/profiler-pack (v1.0.4): [11.9MiB/59.44s] [11.9MiB/59.73s] Downloading (100%)[11.9MiB/59.73s] [11.2MiB/60.07s] Package zendframework/zend-eventmanager is abandoned, you should avoid using it. Use laminas/laminas-eventmanager instead. [11.2MiB/60.07s] Package zendframework/zend-code is abandoned, you should avoid using it. Use laminas/laminas-code instead. [11.2MiB/60.07s] Package symfony/lts is abandoned, you should avoid using it. Use symfony/flex instead. [11.2MiB/60.07s] Package phpunit/phpunit-mock-objects is abandoned, you should avoid using it. No replacement was suggested. [11.2MiB/60.07s] Generating autoload files [11.5MiB/60.12s] 5 packages you are using are looking for funding. [11.5MiB/60.12s] Use the `composer fund` command to find out more! [11.4MiB/60.12s] Memory usage: 11.41MiB (peak: 12.86MiB), time: 60.12s composer 2.0-alpha1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 www-data@grzegorz-php74:~/project$ composer install --no-cache --no-scripts --profile [8.9MiB/0.01s] Installing dependencies from lock file (including require-dev) [9.9MiB/0.02s] Verifying lock file contents can be installed on current platform. [11.5MiB/0.05s] Package operations: 128 installs, 0 updates, 0 removals [11.6MiB/0.05s] - Downloading ocramius/package-versions (1.8.0) ... [14.3MiB/0.10s] - Downloading symfony/validator (v4.2.8) [13.6MiB/12.92s] - Installing ocramius/package-versions (1.8.0): Extracting archive ... [18.0MiB/17.99s] - Installing symfony/validator (v4.2.8): Extracting archive [16.3MiB/22.92s] Package symfony/lts is abandoned, you should avoid using it. Use symfony/flex instead. [16.3MiB/22.92s] Package symfony/lts is abandoned, you should avoid using it. Use symfony/flex instead. [16.3MiB/22.92s] Package zendframework/zend-code is abandoned, you should avoid using it. Use laminas/laminas-code instead. [16.3MiB/22.92s] Package zendframework/zend-eventmanager is abandoned, you should avoid using it. Use laminas/laminas-eventmanager instead. [16.3MiB/22.92s] Package phpunit/phpunit-mock-objects is abandoned, you should avoid using it. No replacement was suggested. [16.3MiB/22.92s] Generating autoload files [16.7MiB/22.98s] 5 packages you are using are looking for funding. [16.7MiB/22.98s] Use the `composer fund` command to find out more! [16.7MiB/22.99s] Memory usage: 16.68MiB (peak: 18.89MiB), time: 22.99s Test composer install Przejdźmy zatem do pierwszego testu – composer install. Testy przeprowadziłem w kontenerze docker z PHP7.4 i synchronizacją mutagen przy użyciu pamięci podręcznej oraz bez niej. Każdy test wykonany został pięciokrotnie, a wyniki zostały uśrednione. Poniżej możemy zobaczyć wykres porównujący czasy instalacji bibliotek testowego projektu z wykorzystaniem composera w wersji 1.10.7 oraz 2.0-alpha1.\nO ile czas z wykorzystaniem cache nie robi wrażenia, o tyle instalacja bez wykorzystania pamięci podręcznej już tak. Mamy tutaj prawie trzy krotne zmniejszenie czasu całej operacji! Jest też mała uwaga, zużycie pamięci wzrosło o około 35%, ale jest to nadal małe zapotrzebowanie pamięci.\nTest composer update oraz composer require Czas na aktualizacje biblioteki. W tej operacji, composer musi sprawdzić całe drzewo zależności, co w wersji pierwszej narzędzia zajmuje bardzo dużo czasu oraz pamięci. Biblioteka jest w najnowszej wersji, więc sprawdzony został jedynie czas przygotowania do pobierania. Samo ściąganie paczek odbywa się według flow opisanego w composer install.\nSprawdziłem również jak wygląda proces dodawania nowej biblioteki do projektu.\nTak jak w pierwszym teście, każdy przypadek sprawdziłem 5 razy, a wyniki zostały uśrednione.\nWydajność drugiej wersji menadżera zależności robi na prawdę duże wrażenie. Czasy zmniejszyły się kilkukrotnie, a zużycie pamięci – no cóż, wykres mówi wszystko.\nUruchomienie jako root wymaga potwierdzenia Od wersji 2.0 composer wymaga potwierdzenia, jeżeli zostanie uruchomiony z konta roota. Jako, że biblioteka może za pomocą composera wykonać dowolny kod na maszynie użytkownika, jest to dobry krok w stronę bezpieczeństwa.\nDry-run Kolejną nowością jest opcja –dry-run dla operacji usuwania (remove) oraz dodawania (require). Czy będzie mocno używana? Nie wiem, ale gdyby ktoś chciał to jest 😀\nNowy format metadanych repozytoriów Wraz z wydaniem wersji drugiej menadżera, dodany został nowy format metadanych repozytoriów. Pierwsza wersja menadżera zależności pobierała ogromy plik JSON. Najnowszy format to zestaw małych plików JSON, które composer może pobrać i zapisać w cache.\nAby sprawdzić, czy dane repozytorium wspiera nowy format, wystarczy, że poszukamy klucza metadata-url w pliku packages.json. Gdy tylko omawiany format jest dostępny, composer 2 będzie korzystał z nowych danych, a wersja pierwsza nadal będzie korzystać tylko ze starego formatu.\nNajpopularniejsze repozytorium paczek Packagist.org wspiera już nowy format.\n","permalink":"https://g-stawarczyk.github.io/2020/06/composer-2.0-sprawd%C5%BAmy-jak-dzia%C5%82a-nowy-menad%C5%BCer-paczek/","summary":"Cześć. W dzisiejszym wpisie sprawdzimy jak działa najnowsza wersja menadżera zależności composer w wersji 2.0.0-alpha1. Porównamy jak wygląda działanie, czas wykonywania zadania oraz zużycie pamięci RAM podczas operacji instalowania, aktualizowania oraz dodawania nowej biblioteki.\nProjekt, na którym będziemy testować menadżera zbudowany jest z wykorzystaniem Symfony 4.2 i wymaga 36 bibliotek – tyle pozycji wpisanych jest w pliku composer.json. Po uwzględnieniu zależności wszystkich bibliotek mamy 128 paczek.\nSzybsze pobieranie Najbardziej wyczekiwaną i zarazem najbardziej zauważalną zmianą w drugiej wersji composera jest zmieniony workflow instalowania, dodawania, aktualizacji czy usuwania paczek, co ma znaczący wpływ na wydajność.","title":"Composer 2.0 – sprawdźmy jak działa nowy menadżer paczek"},{"content":"Dzisiaj, krótki wpis na temat powtarzania treści w docker-compose.\nCzy wiesz, że zasadę DRY można zastosować również w pliku docker-compose? Nie jest to jednak mechanizm samego dockera a języka YAML. Mowa tutaj o funkcjach anchor oraz merge.\nJak to wygląda w praktyce? Wyobraźmy sobie, że nasze środowisko lokalne nie jest unikalne dla każdego projektu, a po prostu mamy 1 plik docker-compose, który uruchamia nam serwer http, bazę danych i kilka wersji PHP. Projekty muszą się komunikować ze sobą, a wszystkie logi zapisujemy do grayloga. Jak może wyglądać wtedy plik docker-compose?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 version: \u0026#39;3.7\u0026#39; services: mysql: hostname: mysql image: mysql:5.7 volumes: - mysql_volume:/var/lib/mysql ports: - 3306:3306 environment: - MYSQL_ROOT_PASSWORD=docker - MYSQL_DATABASE=db - MYSQL_USER=user - MYSQL_PASSWORD=password networks: mynet: logging: driver: gelf options: gelf-address: \u0026#34;udp://1.2.3.4:12201\u0026#34; nginx: hostname: nginx build: context: docker/nginx args: - WWW_DATA_UID=${WWW_DATA_UID} ports: - 8080:80 volumes: - ~/.composer:/var/www/.composer:delegated - ../project_one:/var/www/app/project_one - ../project_two:/var/www/app/project_two networks: mynet: ipv4_address: 172.26.0.6 logging: driver: gelf options: gelf-address: \u0026#34;udp://1.2.3.4:12201\u0026#34; php73: hostname: php73 build: context: docker/php/php73-fpm args: - WWW_DATA_UID=${WWW_DATA_UID} volumes: - ~/.composer:/var/www/.composer:delegated - ../project_one:/var/www/app/project_one - ../project_two:/var/www/app/project_two extra_hosts: - \u0026#34;project-one.local:172.26.0.6\u0026#34; - \u0026#34;project-two.local:172.26.0.6\u0026#34; networks: mynet: logging: driver: gelf options: gelf-address: \u0026#34;udp://1.2.3.4:12201\u0026#34; php74: hostname: php74 build: context: docker/php/php74-fpm args: - WWW_DATA_UID=${WWW_DATA_UID} volumes: - ~/.composer:/var/www/.composer:delegated - ../project_one:/var/www/app/project_one - ../project_two:/var/www/app/project_two extra_hosts: - \u0026#34;project-one.local:172.26.0.6\u0026#34; - \u0026#34;project-two.local:172.26.0.6\u0026#34; networks: mynet: logging: driver: gelf options: gelf-address: \u0026#34;udp://1.2.3.4:12201\u0026#34; networks: mynet: driver: bridge ipam: config: - subnet: 172.26.0.0/24 volumes: mysql_volume: Sporo powtórzeń prawda? 4 kontenery, a prawie 90 linii kodu. Jednak duża objętość to nie wszystkie minusy. W sytuacji, kiedy będziemy chcieli dodać kolejny projekt, musimy zrobić zmianę w wolumenach oraz hostach. Musimy więc edytować volume w trzech kontenerach i extra_hosts w dwóch.\nAnchor i Merge Z pomocą przychodzą nam funkcję anchor oraz merge. Jak one działają? Zobaczmy to na poniższych przykładach. Lewa kolumna to zapis skrócony, a prawa to wynik co widzi parser:\n1 2 3 4 5 anchor: \u0026amp;app key_one: 1 key_two: value merge: *app 1 2 3 4 5 6 7 anchor: key_one: 1 key_two: value merge: key_one: 1 key_two: value Oba klucze będą miały taką samą treść – key_one oraz key_two. Możemy łączyć więcej niż 1 element w całość:\n1 2 3 4 5 6 7 8 anchor_one: \u0026amp;app key_one: 1 anchor_two: \u0026amp;app2 key_two: value merge: \u0026lt;\u0026lt;: [*app, *app2] 1 2 3 4 5 6 7 8 9 anchor_one: key_one: 1 anchor_two: key_two: value merge: key_one: 1 key_two: value Możemy również nadpisywać wartości z kotwic\n1 2 3 4 5 6 7 anchor: \u0026amp;app key_one: 1 key_two: value merge: \u0026lt;\u0026lt;: *app key_two: value2 1 2 3 4 5 6 7 anchor: key_one: 1 key_two: value merge: key_one: 1 key_two: value2 Połączmy wszystko w całość Skoro teorię mamy już za sobą, to sprawdźmy jak możemy zmienić przykładowy docker-compose, aby nie zawierał zbędnych powtórzeń. Z powtarzających się elementów mamy: volume, network, logging oraz extra_hosts.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 version: \u0026#39;3.7\u0026#39; x-default_hosts: \u0026amp;hosts extra_hosts: - \u0026#34;project-one.local:172.26.0.6\u0026#34; - \u0026#34;project-two.local:172.26.0.6\u0026#34; x-default_service: \u0026amp;default_service networks: mynet: logging: driver: gelf options: gelf-address: \u0026#34;udp://1.2.3.4:12201\u0026#34; x-default_volumes: \u0026amp;appvolumes volumes: - ~/.composer:/var/www/.composer:delegated - ../project_one:/var/www/app/project_one - ../project_two:/var/www/app/project_two services: mysql: \u0026lt;\u0026lt;: *default_service hostname: mysql image: mysql:5.7 volumes: - mysql_volume:/var/lib/mysql ports: - 3306:3306 environment: - MYSQL_ROOT_PASSWORD=docker - MYSQL_DATABASE=db - MYSQL_USER=user - MYSQL_PASSWORD=password nginx: \u0026lt;\u0026lt;: [*default_service, *appvolumes] hostname: nginx build: context: docker/nginx args: - WWW_DATA_UID=${WWW_DATA_UID} ports: - 8080:80 networks: mynet: ipv4_address: 172.26.0.6 php73: \u0026lt;\u0026lt;: [*default_service, *appvolumes, *hosts] hostname: php73 build: context: docker/php/php73-fpm args: - WWW_DATA_UID=${WWW_DATA_UID} php74: \u0026lt;\u0026lt;: [*default_service, *appvolumes, *hosts] hostname: php74 build: context: docker/php/php74-fpm args: - WWW_DATA_UID=${WWW_DATA_UID} networks: mynet: driver: bridge ipam: config: - subnet: 172.26.0.0/24 volumes: mysql_volume: Z 88 linii zmniejszyliśmy kod do 71, ale nie to jest najważniejsze. Zyskaliśmy czytelność i łatwość zmian poszczególnych fragmentów kodu.\nKod, który tutaj opisałem jest możliwy do osiągnięcia od wersji pliku 3.4. Jeżeli używasz niższej wersji, możesz również użyć anchor oraz merge, jednak nie możesz zdefiniować własnych obiektów, ponieważ docker-compose na to nie pozwala. Możesz to obejść stosując kotwice w definicji serwisu i wykorzystać ją w kolejnym:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 version: \u0026#39;3.7\u0026#39; services: mysql: hostname: mysql image: mysql:5.7 volumes: - mysql_volume:/var/lib/mysql ports: - 3306:3306 environment: - MYSQL_ROOT_PASSWORD=docker - MYSQL_DATABASE=db - MYSQL_USER=user - MYSQL_PASSWORD=password networks: \u0026amp;appnetwork mynet: logging: \u0026amp;applogging driver: gelf options: gelf-address: \u0026#34;udp://1.2.3.4:12201\u0026#34; nginx: hostname: nginx build: context: docker/nginx args: - WWW_DATA_UID=${WWW_DATA_UID} ports: - 8080:80 logging: *applogging volumes: \u0026amp;appvolumes - ~/.composer:/var/www/.composer:delegated - ../project_one:/var/www/app/project_one - ../project_two:/var/www/app/project_two networks: mynet: ipv4_address: 172.26.0.6 php73: hostname: php73 build: context: docker/php/php73-fpm args: - WWW_DATA_UID=${WWW_DATA_UID} volumes: *appvolumes logging: *applogging networks: *appnetwork extra_hosts: \u0026amp;apphosts - \u0026#34;project-one.local:172.26.0.6\u0026#34; - \u0026#34;project-two.local:172.26.0.6\u0026#34; php74: hostname: php74 build: context: docker/php/php74-fpm args: - WWW_DATA_UID=${WWW_DATA_UID} volumes: *appvolumes logging: *applogging networks: *appnetwork extra_hosts: *apphosts networks: mynet: driver: bridge ipam: config: - subnet: 172.26.0.0/24 volumes: mysql_volume: Kodu jest trochę mniej, ale według mnie ucierpiała tutaj czytelność i łatwość dodania nowych funkcji do wszystkich kontenerów na raz.\nDaj znać w komentarzu, czy podobał Ci się artykuł. Daj to niesamowitej energii do pisania kolejnych treści. Sprawdź również mój wcześniejszy artykuł na temat optymalizacji docker for mac.\n","permalink":"https://g-stawarczyk.github.io/2020/06/docker-compose-dont-repeat-yourself/","summary":"Dzisiaj, krótki wpis na temat powtarzania treści w docker-compose.\nCzy wiesz, że zasadę DRY można zastosować również w pliku docker-compose? Nie jest to jednak mechanizm samego dockera a języka YAML. Mowa tutaj o funkcjach anchor oraz merge.\nJak to wygląda w praktyce? Wyobraźmy sobie, że nasze środowisko lokalne nie jest unikalne dla każdego projektu, a po prostu mamy 1 plik docker-compose, który uruchamia nam serwer http, bazę danych i kilka wersji PHP.","title":"Docker Compose – Don’t repeat yourself"},{"content":"Jeśli również pracujesz na Macu i masz problem z wolno działającym Docker for Mac, to mam dla Ciebie kilka tricków, które przyspieszą działanie Twojego Dockera bez dodatkowych narzędzi.\nAle na początek, jak wyglądają czasy jednego z projektów nad którym pracuje. Zobaczmy więc docker-compose. Możemy w nim zauważyć montowanie wolumenu do kontenera nginx i nadanie mu aliasu, który wykorzystujemy w kontenerze PHP.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 version: \u0026#39;2\u0026#39; services: nginx: hostname: nginx build: context: docker/nginx ports: - 8080:80 volumes: \u0026amp;appvolumes - ../:/var/www/app networks: mynet: ipv4_address: 172.26.0.1 php74: hostname: php74 build: context: docker/php/php74-fpm volumes: *appvolumes networks: mynet: ipv4_address: 172.26.0.2 Jak sami widzicie, czasy są nie do zaakceptowania. A jest to tylko jedna prosta podstrona aplikacji z wykorzystaniem Symfony.\nCo możemy w takiej sytuacji zrobić? Sprawdźmy jak będą wyglądały czasy po wprowadzeniu kilku poprawek wydajnościowych.\n1. Używaj NFS Po pierwsze wykorzystaj NFS do synchronizacji danych między hostem lokalnym a kontenerem. Przyspieszy to działanie dockera.\nPobieramy plik z gist – https://gist.github.com/seanhandley/7dad300420e5f8f02e7243b7651c6657#file-setup_native_nfs_docker_osx-sh Uruchamiamy pobrany wcześniej skrypt Modyfikujemy docker-compose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 version: \u0026#39;2\u0026#39; volumes: nfsmount: driver: local driver_opts: type: nfs o: addr=host.docker.internal,rw,nolock,hard,nointr,nfsvers=3 device: \u0026#34;/absolute/path/to/project/dir\u0026#34; services: nginx: hostname: nginx build: context: docker/nginx ports: - 8080:80 volumes: \u0026amp;appvolumes - nfsmount:/var/www/app ... Uruchamiamy kontener Jak to wygląda teraz dla tej samej strony? Na pewno duże lepiej, ale nadal nie jest idealnie.\nPierwsze załadowanie po zmianach w kodzie\nKolejne załadowanie strony\n2. Wyrzuć niepotrzebne sprawdzanie katalogów Docker for Mac domyślnie ma ustawione kilka głównych katalogów, które za każdym razem sprawdza czy, któryś plik się nie zmienił. Jeżeli używamy NFS’a jest to zbędna operacja, która tylko zajmuje czas. Nie potrzebujemy, aby docker zajmował się sprawdzaniem i synchronizacją plików między hostem a kontenerem, ponieważ mamy od tego NFS.\nWchodzimy więc w ustawienia Docker for Mac \u0026gt; Resources \u0026gt; File sharing, a następnie usuwamy wszystkie pozycje. Jeżeli jednak potrzebujecie synchronizować jakiś katalog bez użycia NFS, wybierzcie jego ścieżkę. Dzięki temu nadal będziecie mogli wykorzystywać synchronizację plików, która zapewnia Docker, a jednocześnie przyspieszycie aplikację.\nUwaga, wykorzystanie tego kroku, praktycznie eliminuje używanie docker run, a co za tym idzie, również nie skorzystamy w dockera w naszym IDE. Wszystko będziemy musieli uruchamiać w działającym kontenerze via CLI.\nSprawdźmy jak teraz działa nasza aplikacja.\nPierwsze załadowanie po zmianach\nKolejne załadowanie strony\nNa prostej stronie nie widzimy zbyt dużej różnicy. Jednak przy większych projektach, ta różnica potrafi być spora.\n3. Wersja Edge – mutagen.io Najnowsza wersja Docker for Mac w wersji Edge wprowadziła możliwość synchronizacji plików przy pomocy mutagen.io. Więcej informacji znajdziesz tutaj: klik. Według mnie będzie to game changer dla osób pracujących na Macu. Dlaczego będzie skoro zostało już wprowadzone? Po pierwsze jest to dopiero w wersji Edge, a po drugie ma jeszcze sporo błędów i widać jedynie Error na liście File Sharing. Błędy, które wystąpiły możemy zobaczyć odpytując lokalne API Dockera:\n1 curl -X GET --unix-socket ~/Library/Containers/com.docker.docker/Data/docker-api.sock http://localhost/cache/state | jq Implementacja mutagena a Dockerze ma problem z linkami absolutnymi w aplikacji. To niestety wyklucza użycie phpunit w symfony:\n1 2 3 4 5 6 7 8 9 { \u0026#34;/Users/grzegorz/dev/project\u0026#34;: { \u0026#34;status\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;ready\u0026#34;: false, \u0026#34;problems\u0026#34;: [ \u0026#34;beta scan error: remote error: invalid symbolic link (project/vendor/bin/.phpunit/phpunit-5.7.27/vendor/symfony/phpunit-bridge): target is absolute\u0026#34; ] } } Mimo wszystko sprawdźmy jak zachowuje się nasza aplikacja po włączeniu mutagena.\n1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;2\u0026#39; services: nginx: hostname: nginx build: context: docker/nginx ports: - 8080:80 volumes: \u0026amp;appvolumes - ../:/var/www/app ... Pierwsze odświeżenie po zmianach w kodzie\nKolejne załadowanie\nWygląda to naprawę dobrze. Ale… Dodajmy jeszcze volumen na cache\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 version: \u0026#39;2\u0026#39; volumes: app_cache: services: nginx: hostname: nginx build: context: docker/nginx ports: - 8080:80 volumes: \u0026amp;appvolumes - ../:/var/www/app - app_cache:/var/www/app/project/var/cache ... Pierwsze załadowanie po zmianach w kodzie\nKolejne odświeżenie strony\nPraca z dockerem na Mac OSX wcale nie musi być utrapieniem. Jeżeli znasz jeszcze inne tricki jak zoptymalizować dockera, koniecznie daj znać w komentarzu.\nP.S. Jeżeli będziesz chciał przejść na Docker Edge, pamiętaj, że pierwsze uruchomienie Docker Edge wyczyści wszystkie obrazy, kontenery oraz wolumeny!! Jeżeli masz kontenery z danymi, których nie chciał byś wyczyścić, zrób koniecznie ich backup.\n","permalink":"https://g-stawarczyk.github.io/2020/06/docker-for-mac-3-sposoby-na-przyspieszenie-dzia%C5%82ania/","summary":"Jeśli również pracujesz na Macu i masz problem z wolno działającym Docker for Mac, to mam dla Ciebie kilka tricków, które przyspieszą działanie Twojego Dockera bez dodatkowych narzędzi.\nAle na początek, jak wyglądają czasy jednego z projektów nad którym pracuje. Zobaczmy więc docker-compose. Możemy w nim zauważyć montowanie wolumenu do kontenera nginx i nadanie mu aliasu, który wykorzystujemy w kontenerze PHP.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 version: \u0026#39;2\u0026#39; services: nginx: hostname: nginx build: context: docker/nginx ports: - 8080:80 volumes: \u0026amp;appvolumes - .","title":"Docker for Mac – 3 sposoby na przyspieszenie działania"},{"content":"Cześć.\nW moim pierwszym wpisie, chciałbym Wam przestawić wzorzec architektoniczny pipe \u0026amp; filters. Jest to sposób na rozbicie dużego zadania na mniejsze części w bardzo przejrzysty sposób. Zaletami takiego rozwiązania jest reużywalność klas (filtrów), możliwość szybkiej zmiany kroków wykonywania danego algorytmu oraz zrównoleglenia procesu. Niewątpliwą zaletą jest również testowalność. Dzięki wyodrębnieniu poszczególnych modułów możemy, każdy z kroków możemy testować w izolacji, na przykład testami jednostkowymi.\nJeśli się nie mylę, historia tego rozwiązania sięga pamięcią do 1973 roku, kiedy to jeden z pomysłów Douglasa McIlroya został zaimplementowany w systemach UNIX. Douglas zauważył, że dane wyjściowe jednego programu mogą stanowić dane wejściowe do drugiego programu. W ten sposób powstały potoki, wywołania programów oddzielonych pionową linią „|” (pipe). Przykład wywołania potoku w systemach UNIX:\ntail -f /var/log/nginx/access.log | grep 500\nW architekturze aplikacyjnej, przykładowym problemem do rozwiązania przez wzorzec pipe \u0026amp; filters może być obróbka pliku. Załóżmy, że mamy spakowany plik CSV, z którego musimy wyciągnąć jakieś dane, a następnie na podstawie wybranych danych wykonać zadanie. Na pierwszy rzut oka możemy zauważyć 3 pod zadania: rozpakowanie pliku, przetworzenie pliku CSV oraz wykonanie zadania.\nRozbicie całego procesu na tak małe zadania pozwala nam na użycie ich w innych pipeline’ach lub po prostu wykorzystanie w dowolnej klasie, które będzie potrzebowała danej funkcji.\nImplementacja wzorca jest bardzo prosta. Klasa Pipeline musi przyjąć kolejne kroki algorytmu, które następnie musi wykonać. Można to zrobić za jednym razem lub zbudować przy pomocy metody. Przykładowa implementacja wzorca w języku PHP przedstawia się następująco:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?php class Pipeline implements PipelineInterface { /** @var callable[] */ private $stages = []; public function __construct(callable ...$stages) { $this-\u0026gt;stages = $stages; } public function pipe(callable $stage): PipelineInterface { $pipeline = clone $this; $pipeline-\u0026gt;stages[] = $stage; return $pipeline; } public function process($payload) { foreach ($this-\u0026gt;stages as $stage) { $payload = $stage($payload); } return $payload; } } Samo wykorzystanie również jest trywialne. Musimy utworzyć nową instancję potoku, przekazać filtry (zadania) w odpowiedniej kolejności i uruchomić proces:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php class Foo { public function __invoke(): SomeClass { $data = ...; return (new Pipeline) -\u0026gt;pipe(new FilterA) -\u0026gt;pipe(new FilterB) -\u0026gt;pipe(new FilterC) -\u0026gt;process(new SomeClass($data)); } } 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php class FilterA { public method __invoke(SomeClass $obj): SomeClass { // Do the magic here :). return $obj; } } Prawda, że proste?\nDajcie znać co myślicie o wzorcu pipe \u0026amp; filters oraz jakie widzicie jego zastosowanie\n","permalink":"https://g-stawarczyk.github.io/2020/06/wzorzec-potok%C3%B3w-i-filtr%C3%B3w-pipe-filters/","summary":"Cześć.\nW moim pierwszym wpisie, chciałbym Wam przestawić wzorzec architektoniczny pipe \u0026amp; filters. Jest to sposób na rozbicie dużego zadania na mniejsze części w bardzo przejrzysty sposób. Zaletami takiego rozwiązania jest reużywalność klas (filtrów), możliwość szybkiej zmiany kroków wykonywania danego algorytmu oraz zrównoleglenia procesu. Niewątpliwą zaletą jest również testowalność. Dzięki wyodrębnieniu poszczególnych modułów możemy, każdy z kroków możemy testować w izolacji, na przykład testami jednostkowymi.\nJeśli się nie mylę, historia tego rozwiązania sięga pamięcią do 1973 roku, kiedy to jeden z pomysłów Douglasa McIlroya został zaimplementowany w systemach UNIX.","title":"Wzorzec potoków i filtrów (pipe \u0026 filters)"}]